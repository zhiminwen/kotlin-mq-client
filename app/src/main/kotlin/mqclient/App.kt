/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package mqclient

import java.io.FileInputStream
import java.security.KeyStore
import java.security.SecureRandom
import java.util.*
import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.TrustManagerFactory
import com.ibm.mq.constants.MQConstants
import com.ibm.mq.MQQueueManager
import com.ibm.mq.MQMessage
import com.ibm.mq.MQPutMessageOptions


class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}


fun mqConnect(): MQQueueManager {
  System.setProperty("com.ibm.mq.cfg.useIBMCipherMappings", "false")
  val sslDebug = System.getenv("MQC_SSL_DEBUG") ?: "NO"
  if (sslDebug == "YES") {
    System.setProperty("javax.net.debug", "ssl:handshake")
  }
  
  data class propFromEnv(val attr: String, val env: String, val default: String)
  val props = Hashtable<String, Any>()

  val attrs = listOf(
      propFromEnv(MQConstants.CHANNEL_PROPERTY, "MQC_CHANNEL", "channel1"),
      propFromEnv(MQConstants.HOST_NAME_PROPERTY, "MQC_HOST_NAME", "localhost"),
      propFromEnv(MQConstants.PORT_PROPERTY, "MQC_PORT", "1414"),
      //important. or it will load jni lib
      propFromEnv(MQConstants.TRANSPORT_PROPERTY, "MQC_TRANSPORT", "MQSeries Client"),
      propFromEnv(MQConstants.SSL_CIPHER_SUITE_PROPERTY, "MQC_CIPHERSUITE", "TLS_RSA_WITH_AES_256_CBC_SHA256"),
  )

  for (a in attrs) {
      props[a.attr] = System.getenv(a.env) ?: a.default
      if (a.attr == "port") {
          props[a.attr] = props[a.attr].toString().toIntOrNull()
      }
  }

  println("props = ${props}")

  val keystoreFile = System.getenv("MQC_KEYSTORE") ?: "/app/cert/mqclient.jks"
  val keystorePass = System.getenv("MQC_KEYSTORE_PASSWORD") ?: "password"
      
  val keystore = KeyStore.getInstance("JKS")
  keystore.load(FileInputStream(keystoreFile), keystorePass.toCharArray())

  val tmf=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
  tmf.init(keystore)

  val kmf = KeyManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
  kmf.init(keystore, keystorePass.toCharArray())
  
  val sslContext = SSLContext.getInstance("TLS")
  sslContext.init(kmf.keyManagers, tmf.trustManagers, SecureRandom());

  props["SSL Socket Factory"]=sslContext.socketFactory

  val qmName = System.getenv("MQC_QM_NAME") ?: "qm1"
  val qmgr = MQQueueManager(qmName, props)

  return qmgr
}

fun putMessage(qmgr: MQQueueManager, queueName: String, msg: String){
  val queue = qmgr.accessQueue(queueName, MQConstants.MQOO_OUTPUT)

  val mqMsg = MQMessage()
  mqMsg.writeString(msg)

  val pmo = MQPutMessageOptions()
  pmo.options = MQConstants.MQPMO_ASYNC_RESPONSE
  
  queue.put(mqMsg, pmo)
  queue.close()

  val status = qmgr.getAsyncStatus()
  println("status = ${status.reasonCode}")
}

fun main(){
    val qmgr = mqConnect()
    putMessage(qmgr, System.getenv("MQC_QUEUE_NAME") ?: "testq1",  "Hello World!")
}

